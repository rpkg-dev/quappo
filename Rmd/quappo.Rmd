---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Avoid `R CMD check` NOTES about undefined global objects

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 ":="))
```

## Functions

### `as_code_chunk_array`

```{r}
as_code_chunk_array <- function(x) {
  
  if (length(x) == 1L) {
    return(paste0("#|   - ", x))
  }
  
  yaml::as.yaml(x) |>
    stringr::str_split_1("\n") %>%
    magrittr::extract(nchar(.) > 0L) %>%
    paste0("#|   ", .,
           collapse = "\n")
}
```

### `as_yaml_inline`

```{r}
as_yaml_inline <- function(x) {
  yaml::as.yaml(x) |> stringr::str_remove(pattern = "\n$")
}
```

## Constants

```{r}
this_pkg <- utils::packageName()
```

# EXPORTED

## `view_output`

TODO:

-   Support projects with no `index.html` output (single files). This requires us to first determine a "main" input file from the `input` dir.

```{r}
#' View Quarto output
#'
#' @description
#' Opens a Quarto project's pre-rendered output of the specified `format` in the RStudio viewer pane or the system's default application. For `"html"`, a local
#' HTTP server is launched that serves the HTML output on [`127.0.0.1:3456`](http://127.0.0.1:3456) by default.
#'
#' This is considerably faster and more responsive than [quarto::quarto_preview] (which runs Quarto in the background and automatically reloads the browser when
#' input files or document resources (e.g. CSS) change).
#'
#' @details
#' Note that the web server started by `view_output()` will continue running in the background until it is explicitly stopped (e.g. via [httpuv::stopServer()]
#' or [httpuv::stopAllServers()]) or the \R session is terminated. An already running web server on `port` is reused if possible (i.e. if it was launched in the
#' same \R session), otherwise a port within the range 1024–49151 (["user" or "registered" ports](https://en.wikipedia.org/wiki/Registered_port)) is randomly
#' chosen using [httpuv::randomPort()].
#'
#' @inheritParams quarto::quarto_inspect
#' @param input Path to [Quarto project](https://quarto.org/docs/projects/quarto-projects.html) directory. A character scalar.
#' @param output_format Quarto output format to open. If [`"html"`](https://quarto.org/docs/reference/formats/html.html), a local HTTP server is launched
#'   serving the projects's HTML output under `host` on the specified `port`.
#' @param host IPv4 address to serve the HTML output on. A character scalar. Only relevant for `format = "html"`.
#' @param port TCP port number to serve the HTML output on. An integer scalar. Note that on most Unix-like systems including Linux and macOS, port numbers
#'   below 1024 require root privileges. If the specified `port` is already occupied, a randomly chosen port between 1025–49151 is used instead. Only relevant
#'   for `format = "html"`.
#' @param in_rstudio_viewer Whether to open the output file in the RStudio viewer pane if possible, i.e. RStudio [is available][rstudioapi::isAvailable]. If
#'   `FALSE` or RStudio is unavailable, the output file is opened in the system's default application for `output_format` via [xopen::xopen()] instead. Note
#'   that only PDFs within the \R session temporary directory can be opened in RStudio's viewer pane, others are automatically passed to the system's default
#'   PDF viewer.
#'
#' @return For `format = "html"`, a [`httpuv::WebServer`][httpuv::WebServer] object. For `format = "pdf"`, the path to the PDF file. Invisibly in both cases.
#' @export
#'
#' @examples
#' \dontrun{
#' # start server
#' s <- quappo::view_output()
#' 
#' # stop server
#' s$stop()}
view_output <- function(input = ".",
                        output_format = "html",
                        profile = NULL,
                        host = "127.0.0.1",
                        port = 3456L,
                        in_rstudio_viewer = interactive()) {
  
  checkmate::assert_string(host)
  checkmate::assert_int(port)
  checkmate::assert_flag(in_rstudio_viewer)
  config <- quarto::quarto_inspect(input = input,
                                   profile = profile)$config
  if (!("project" %in% names(config))) {
    cli::cli_abort("Missing Quarto configuration object {.href [`project`](https://quarto.org/docs/reference/projects/options.html)}.")
  }
  if ("output-dir" %in% names(config$project)) {
    output_dir <- fs::path_abs(config$project$`output-dir`,
                               start = input)
  } else {
    output_dir <- input
  }
  
  if (!pal::is_pkg_installed("rstudioapi")) {
    in_rstudio_viewer <- FALSE
  }
  
  if (output_format == "html") {
    
    # ensure `index.html` exists since we only support whole sites for now
    if (!fs::file_exists(fs::path(output_dir, "index.html"))) {
      cli::cli_abort(paste0("No {.file index.html} file found under {.path {output_dir}}. Please first render the specified Quarto project ",
                            "({.href [book](https://quarto.org/docs/books/)} or {.href [website](https://quarto.org/docs/websites/)}) to ",
                            "{.val {output_format}} (e.g. using {.fun quarto::quarto_render}) and then try again."))
    }
    
    is_port_available <- utils::getFromNamespace(x = "is_port_available",
                                                 ns = "httpuv")
    paths_static <- list("/" = fs::path_abs(output_dir))
    servers <- httpuv::listServers()
    ports <- purrr::map_int(servers,
                            \(x) x$getPort())
    hosts <- purrr::map_chr(servers,
                            \(x) x$getHost())
    i_port <- which(ports %in% port & hosts %in% host)
    if (length(i_port) > 1L) {
      i_port <- i_port[1L]
    }
    
    # re-use already running server if available...
    if (length(i_port) > 0L && servers[[i_port]]$isRunning()) {
      result <- servers[[i_port]]
      result$setStaticPath(.list = paths_static)
      # ... otherwise launch new server instance
    } else {
      if (!is_port_available(port = port)) {
        port_occupied <- port
        port <- httpuv::randomPort(host = host,
                                   n = 48127L)
        cli::cli_alert_info(paste0("The specified {.arg port} number {.val {port_occupied}} is already in use by another application, thus the randomly chosen",
                                   " port number {.val {port}} is used instead."))
      }
      result <- httpuv::startServer(host = host,
                                    port = port,
                                    app = list(staticPaths = paths_static))
    }
    
    target <- glue::glue("http://{host}:{port}")
    
  } else {
    
    target <-
      config$book$`output-file` %||%
      stringr::str_replace_all(string = config$book$title,
                               pattern = "\\s",
                               replacement = "-") |>
      pal::when(length(.) == 0L ~ fs::path_file(output_dir),
                ~ .) |>
      fs::path(ext = output_format) |>
      fs::path_abs(start = output_dir)
    
    if (!fs::file_exists(target)) {
      cli::cli_abort(paste0("No output file found under {.path {target}}. Please first render the specified Quarto project to {.val output_format} (e.g. ",
                            "using {.fun quarto::quarto_render}) and then try again."))
    }
    
    result <- target
  }
  
  if (in_rstudio_viewer && rstudioapi::isAvailable()) {
    rstudioapi::viewer(url = target)
  } else {
    xopen::xopen(target = target)
  }
  
  invisible(result)
}
```

## Code chunks

### DESCRIPTION

Functions to generate and process [Quarto code chunks](https://quarto.org/docs/reference/cells/cells-knitr.html) (aka "code cells").

### `fig_chunk`

```{r}
#' Assemble Quarto knitr figure chunk
#'
#' Assembles a [Quarto knitr figure chunk](https://quarto.org/docs/authoring/figures.html#computations).
#'
#' Use [substitute] together with [deparse1()] to convert \R expressions to a character scalar as expected by param `body`:
#'
#' ```r
#' deparse1(expr = substitute(do_something()),
#'          collapse = "\n")
#' ```
#'
#' @param body \R code to insert into the code chunk's body. A character scalar.
#' @param label Unique code chunk label. Set as Quarto's [`label`](https://quarto.org/docs/reference/cells/cells-knitr.html#figures) code chunk option. A 
#'   character scalar that starts with `"fig-"`.
#' @param fig_cap Figure caption. Set as Quarto's [`fig-cap`](https://quarto.org/docs/reference/cells/cells-knitr.html#figures) code chunk option. A character
#'   scalar.
#' @param fig_subcap Figure subcaptions. Set as Quarto's [`fig-subcap`](https://quarto.org/docs/reference/cells/cells-knitr.html#figures) code chunk option. A
#'   character vector, or `NULL` to omit.
#' @param fig_column Quarto [article layout class](https://quarto.org/docs/authoring/article-layout.html#available-columns) for the figure output. Set as
#'   Quarto's [`fig-column`](https://quarto.org/docs/reference/cells/cells-knitr.html#page-columns) code chunk option. Either `NULL` to omit or one of
#'   `r pal::as_md_val_list(qmd_layout_classes)`
#' @param fig_width Width of the plot (in inches), to be used in the graphics device. Set as Quarto's
#'   [`fig-width`](https://quarto.org/docs/reference/cells/cells-knitr.html#figures) code chunk option. A numeric scalar, or `NULL` to omit.
#' @param fig_height Height of the plot (in inches), to be used in the graphics device. Set as Quarto's
#'   [`fig-height`](https://quarto.org/docs/reference/cells/cells-knitr.html#figures) code chunk option. A numeric scalar, or `NULL` to omit.
#' @param fig_pos LaTeX figure position arrangement to be used in `\begin{figure}[]`. Set as Quarto's
#'   [`fig-pos`](https://quarto.org/docs/reference/cells/cells-knitr.html#figures) code chunk option. A character scalar, or `NULL` to omit. Use `"false"` for
#'   no figure position specifier, which is sometimes necessary with custom figure environments (such as `sidewaysfigure`).
#' @param fig_link Hyperlink target for the figure. Set as Quarto's [`fig-link`](https://quarto.org/docs/reference/cells/cells-knitr.html#figures) code chunk
#'   option. A character scalar, or `NULL` to omit.
#' @param column Quarto [article layout class](https://quarto.org/docs/authoring/article-layout.html#available-columns) for all of the code chunk's output. Set
#'   as Quarto's [`column`](https://quarto.org/docs/reference/cells/cells-knitr.html#page-columns) code chunk option. Either `NULL` to omit or one of
#'   `r pal::as_md_val_list(qmd_layout_classes)`
#' @param out_width Width of the plot in the output document, which can be different from its physical `fig_width`, i.e., plots can be scaled in the output
#'   document. Set as Quarto's [`out-width`](https://quarto.org/docs/reference/cells/cells-knitr.html#figures) code chunk option. A character scalar, or `NULL`
#'   to omit.
#' @param out_height Height of the plot in the output document, which can be different from its physical `fig_height`, i.e., plots can be scaled in the output
#'   document. Set as Quarto's [`out-height`](https://quarto.org/docs/reference/cells/cells-knitr.html#figures) code chunk option. A character scalar, or `NULL`
#'   to omit.
#'
#' @return A character scalar.
#' @family chunks
#' @export
#'
#' @examples
#' quappo::fig_chunk(body = "plot(cars)",
#'                   label = "fig-mtcars",
#'                   fig_cap = "Default plot for dataset `cars`",
#'                   fig_column = "page")
fig_chunk <- function(body,
                      label,
                      fig_cap,
                      fig_subcap = NULL,
                      fig_column = NULL,
                      fig_width = NULL,
                      fig_height = NULL,
                      fig_pos = "H",
                      fig_link = NULL,
                      column = NULL,
                      out_width = NULL,
                      out_height = NULL) {
  
  checkmate::assert_string(body)
  checkmate::assert_string(label,
                           pattern = "^fig-.+")
  checkmate::assert_character(fig_cap,
                              any.missing = FALSE,
                              min.len = 1L,
                              null.ok = TRUE)
  checkmate::assert_character(fig_subcap,
                              any.missing = FALSE,
                              null.ok = TRUE)
  checkmate::assert_number(fig_width,
                           lower = 0.0,
                           null.ok = TRUE)
  checkmate::assert_number(fig_height,
                           lower = 0.0,
                           null.ok = TRUE)
  checkmate::assert_string(fig_pos,
                           null.ok = TRUE)
  checkmate::assert_string(fig_link,
                           null.ok = TRUE)
  checkmate::assert_string(out_width,
                           null.ok = TRUE)
  checkmate::assert_string(out_height,
                           null.ok = TRUE)
  if (!is.null(fig_column)) {
    fig_column <- rlang::arg_match(arg = fig_column,
                                   values = qmd_layout_classes)
  }
  if (!is.null(column)) {
    column <- rlang::arg_match(arg = column,
                               values = qmd_layout_classes)
  }
  is_fig_cap_scalar <- length(fig_cap) == 1L
  has_fig_subcap <- length(fig_subcap) > 0L
  
  # convert to YAML array
  if (has_fig_subcap) {
    fig_subcap %<>% as_code_chunk_array()
  }
  
  # assemble code chunk
  glue::glue(paste0(c("```{{r}}",
                      "#| label: {as_yaml_inline(label)}",
                      "#| fig-cap:",
                      as_code_chunk_array(fig_cap),
                      "#| fig-subcap:"[has_fig_subcap],
                      fig_subcap,
                      "#| fig-column: {fig_column}"[!is.null(fig_column)],
                      "#| fig-width: {as_yaml_inline(fig_width)}"[!is.null(fig_width)],
                      "#| fig-height: {as_yaml_inline(fig_height)}"[!is.null(fig_height)],
                      "#| fig-pos: {fig_pos}"[!is.null(fig_pos)],
                      "#| fig-link: {as_yaml_inline(fig_link)}"[length(fig_link) > 0L],
                      "#| column: {column}"[!is.null(column)],
                      "#| out-width: {as_yaml_inline(out_width)}"[!is.null(out_width)],
                      "#| out-height: {as_yaml_inline(out_height)}"[!is.null(out_height)],
                      "",
                      "{body}",
                      "```",
                      "",
                      ""),
                    collapse = "\n"))
}
```

### `tbl_chunk`

```{r}
#' Assemble Quarto knitr table chunk
#'
#' Assembles a [Quarto knitr table chunk](https://quarto.org/docs/authoring/tables.html#computations).
#'
#' Use [substitute] together with [deparse1()] to convert \R expressions to a character scalar as expected by param `body`:
#'
#' ```r
#' deparse1(expr = substitute(do_something()),
#'          collapse = "\n")
#' ```
#'
#' @inheritParams fig_chunk
#' @param body \R code to insert into the code chunk's body. A character scalar.
#' @param label Unique code chunk label. Set as Quarto's [`label`](https://quarto.org/docs/reference/cells/cells-knitr.html#tables) code chunk option. A 
#'   character scalar that starts with `"tbl-"`.
#' @param tbl_cap Table caption. Set as Quarto's [`tbl-cap`](https://quarto.org/docs/reference/cells/cells-knitr.html#tables) code chunk option. A character
#'   scalar.
#' @param tbl_subcap Table subcaptions. Set as Quarto's [`tbl-subcap`](https://quarto.org/docs/reference/cells/cells-knitr.html#tables) code chunk option. A
#'   character vector.
#' @param tbl_colwidths Apply explicit table column widths for Markdown [grid tables](https://pandoc.org/MANUAL.html#extension-grid_tables) and [pipe
#'   tables](https://pandoc.org/MANUAL.html#extension-pipe_tables) that are more than `columns` characters wide (72 by default).
#' 
#'   Some formats (e.g. HTML) do an excellent job automatically sizing table columns and so don’t benefit much from column width specifications. Other formats
#'   (e.g. LaTeX) require table column sizes in order to correctly flow longer cell content (this is a major reason why tables > 72 columns wide are assigned
#'   explicit widths by Pandoc).
#'   
#'   This can be specified as:
#'   
#'   - `"auto"`: Apply Markdown table column widths except when there is a hyperlink in the table (which tends to throw off automatic calculation of column
#'     widths based on the Markdown text width of cells). `"auto"` is the default for HTML output formats.
#'     
#'   - `"true"`: Always apply Markdown table widths. `"true"` is the default for all non-HTML formats.
#'  
#'   - `"false"`: Never apply Markdown table widths.
#'  
#'   - A numeric vector (e.g. `c(40, 30, 30)`): Array of explicit width percentages.
#' @param tbl_column Quarto [article layout class](https://quarto.org/docs/authoring/article-layout.html#available-columns) for the figure output. Set as
#'   Quarto's [`tbl-column`](https://quarto.org/docs/reference/cells/cells-knitr.html#page-columns) code chunk option. Either `NULL` to omit or one of
#'   `r pal::as_md_val_list(qmd_layout_classes)`
#'
#' @return A character scalar.
#' @family chunks
#' @export
#'
#' @examples
#' quappo::tbl_chunk(body = "knitr::kable(head(cars))",
#'                   label = "tbl-head-cars",
#'                   tbl_cap = "Head of dataset `cars`",
#'                   tbl_column = "margin")
tbl_chunk <- function(body,
                      label,
                      tbl_cap,
                      tbl_subcap = NULL,
                      tbl_colwidths = NULL,
                      tbl_column = NULL,
                      column = NULL) {
  
  checkmate::assert_string(body)
  checkmate::assert_string(label,
                           pattern = "^tbl-.+")
  checkmate::assert_string(tbl_cap)
  checkmate::assert_character(tbl_subcap,
                              any.missing = FALSE,
                              null.ok = TRUE)
  is_str_tbl_colwidths <- checkmate::test_choice(tbl_colwidths,
                                                 choices = c("auto", "true", "false"))
  is_num_tbl_colwidths <- checkmate::test_numeric(tbl_colwidths,
                                                  min.len = 1L)
  if (!(is.null(tbl_colwidths) || is_str_tbl_colwidths || is_num_tbl_colwidths)) {
    cli::cli_abort('{.arg tbl_colwidths} must be either one of {.val {"auto"}}, {.val {"true"}} or {.val {"false"}}, or a numeric vector.')
  }
  if (!is.null(tbl_column)) {
    tbl_column <- rlang::arg_match(arg = tbl_column,
                                   values = qmd_layout_classes)
  }
  if (!is.null(column)) {
    column <- rlang::arg_match(arg = column,
                               values = qmd_layout_classes)
  }
  has_tbl_subcap <- length(tbl_subcap) > 0L
  
  # convert to YAML array
  if (has_tbl_subcap) {
    tbl_subcap %<>% as_code_chunk_array()
  }
  
  # assemble code chunk
  glue::glue(paste0(c("```{{r}}",
                      "#| label: {as_yaml_inline(label)}",
                      "#| tbl-cap:",
                      as_code_chunk_array(tbl_cap),
                      "#| tbl-subcap:"[has_tbl_subcap],
                      tbl_subcap,
                      "#| tbl-colwidths: {tbl_colwidths}"[is_str_tbl_colwidths],
                      "#| tbl-colwidths:"[is_num_tbl_colwidths],
                      as_code_chunk_array(tbl_colwidths)[is_num_tbl_colwidths],
                      "#| tbl-column: {tbl_column}"[!is.null(tbl_column)],
                      "#| column: {column}"[!is.null(column)],
                      "",
                      "{body}",
                      "```",
                      "",
                      ""),
                    collapse = "\n"))
}
```

### `chunks`

```{r}
#' Generate Quarto knitr code chunk snippets from structured data
#'
#' Generates Quarto Markdown (`.qmd`) file snippets with knitr [figure][fig_chunk] or [table][tbl_chunk] code chunks from structured `data`.
#'
#' The generated `.qmd` files are intended to be included in other Quarto documents via the built-in
#' [`include`](https://quarto.org/docs/authoring/includes.html) shortcode.
#'
#' # Input `data`
#'
#' All `data` columns of type character are [cli::pluralize()]d, meaning literal curly brackets (`{` and `}`) need to be escaped by doubling them (to `{{` and
#' `}}`).
#' 
#' The column names of `data` can either correspond to [fig_chunk()]/[tbl_chunk()]'s argument names (in [snake
#' case](https://en.wikipedia.org/wiki/Snake_case)), to [knitr's figure chunk option names](https://yihui.org/knitr/options/#plots) (period-separared) or
#' directly to Quarto's
#' [figure](https://quarto.org/docs/reference/cells/cells-knitr.html#figures)/[table](https://quarto.org/docs/reference/cells/cells-knitr.html#tables) code
#' chunk option names (in [kebab case](https://en.wikipedia.org/wiki/Letter_case#Kebab_case)) – they will be converted as needed.
#' 
#' Additional column names are silently ignored, except for the optional iteration variable columns `itr_vars` (of type list) and `itr_vars_r` (of type
#' character).
#' 
#' # Iteration variables
#' 
#' Specifying iteration variables allows to produce multiple code chunks per `data` row. The iteration variables can be referred to in the other columns via
#' [cli::pluralize()]'s string interpolation syntax (i.e. R code in curly brackets).
#' 
#' The `itr_vars` column must be a list of named lists (or `NULL` for no iteration on the respective rows). The `itr_vars_r` column allows to specify `itr_vars`
#' as a string of R code (which must yield a list of named lists / `NULL`s when parsed and executed).
#'
#' @param data Input data as returned by [read_chunk_toml()]. A dataframe where column names correspond to chunk options supported by [fig_chunk()] or
#'   [tbl_chunk()] plus the optional iteration variable columns `itr_vars` and `itr_vars_r`. Columns `body`, `label` and `fig_cap`/`tbl_cap` are mandatory. See
#'   section *Input `data`* for details.
#' @param env Environment to evaluate iterations in (see section *Iteration variables* for details).
#'
#' @return `data`, invisibly.
#' @family chunks
#' @export
#'
#' @examples
#' # data row without iterations
#' tibble::tibble(label = "fig-cars",
#'                fig_cap = "Today's ({clock::date_today(zone = Sys.timezone())}) top figure",
#'                fig_column = "page",
#'                fig_height = 8L,
#'                body = "plot(cars)") |>
#'   quappo::chunks()
#'
#' # data row with iteration variables specified directly as `itr_vars`
#' tibble::tibble(itr_vars = list(list(v = "cyl"),
#'                                list(v = "disp"),
#'                                list(v = "hp")),
#'                label = "fig-mpg-by-{v}",
#'                fig_cap = "Motor Trend Car Road Tests: mpg per {v}",
#'                fig_column = "screen",
#'                fig_height = 8L,
#'                body = "plot(x = mtcars$mpg, y = mtcars${v})") |>
#'   quappo::chunks()
#'
#' # data row with iteration variables specified indirectly as `itr_vars_r` code
#' tibble::tibble(itr_vars_r = "purrr::map(colnames(mtcars)[5:7], \\(x) list(v = x))",
#'                label = "fig-mpg-by-{v}",
#'                fig_cap = "Motor Trend Car Road Tests: mpg per {v}",
#'                fig_column = "screen",
#'                fig_height = 8L,
#'                body = "plot(x = mtcars$mpg, y = mtcars${v})") |>
#'   quappo::chunks()
# nolint start: cyclocomp_linter
chunks <- function(data,
                   env = parent.frame()) {
  
  checkmate::assert_data_frame(data,
                               all.missing = FALSE,
                               min.cols = 2L)
  # normalize names
  data %<>% magrittr::set_colnames(value = stringr::str_replace_all(string = colnames(.),
                                                                    pattern = "[-.]",
                                                                    replacement = "_"))
  # ensure mandatory cols are present
  if (!("body" %in% colnames(data))) cli::cli_abort("{.arg data} must contain a column {.var body}.")
  if (!("label" %in% colnames(data))) cli::cli_abort("{.arg data} must contain a column {.var label}.")
  if (!("fig_cap" %in% colnames(data))) cli::cli_abort("{.arg data} must contain a column {.var fig_cap}.")
  # ensure mandatory vals aren't NA
  if (anyNA(data$body)) cli::cli_abort("{.arg data} column {.var body} mustn't contain {.val {NA}} values.")
  if (anyNA(data$label)) cli::cli_abort("{.arg data} column {.var label} mustn't contain {.val {NA}} values.")
  if (anyNA(data$fig_cap)) cli::cli_abort("{.arg data} column {.var fig_cap} mustn't contain {.val {NA}} values.")
  # add empty `itr_vars` col if it's missing
  if (!("itr_vars" %in% colnames(data))) {
    data %<>% tibble::add_column(itr_vars = rep(x = list(NULL),
                                                times = nrow(.))) 
  }
  # expand `itr_vars_r` to `itr_vars` (one-to-many rows)
  if ("itr_vars_r" %in% colnames(data)) {
    
    data %<>%
      purrr::pmap(\(itr_vars, itr_vars_r, ...) {
        
        if (is.na(itr_vars_r)) {
          
          itr_vars <- list(itr_vars)
          
        } else {
          
          if (!is.null(itr_vars)) {
            cli::cli_abort("A {.arg data} row cannot have both {.var itr_vars} and {.var itr_vars_r} set at the same time.")
          }
          
          itr_vars <- eval(parse(text = itr_vars_r),
                           envir = env)
        }
        
        tibble::tibble(itr_vars = itr_vars,
                       ...)
      }) %>%
      purrr::list_rbind()
  }
  
  # ensure lbls are unique
  ## exclude iterated lbls
  dupl_lbls <- stringr::str_subset(string = data$label,
                                   pattern = "\\{[^{].*?\\}",
                                   negate = TRUE)
  ix_dupl_lbls <- which(duplicated(dupl_lbls))
  
  if (length(ix_dupl_lbls) > 0L) {
    cli::cli_abort("Labels in column {.var label} must be unique, which the following label{?s} {?is/are} not: {.val {unique(dupl_lbls[ix_dupl_lbls])}}")
  }
  
  ## ensure lbls and itr_vars congruency
  has_itr_lbl <- stringr::str_detect(string = data$label,
                                     pattern = "\\{[^{].*?\\}")
  has_itr_col <- !purrr::map_lgl(data$itr_vars,
                                 is.null)
  if (any(has_itr_lbl & !has_itr_col)) {
    cli::cli_abort("All {.arg data} rows with a {.arg label} to be iterated must have proper {.var itr_vars} set.")
  }
  
  data |>
    purrr::pmap(\(...) {
      
      args <- rlang::list2(...)
      
      # remove `NA`'s (equivalent to `NULL` later on)
      args[is.na(args)] <- NULL
      
      # interpolate chunk opts
      if (!is.null(args$itr_vars)) {
        
        if (!rlang::is_named(args$itr_vars)) {
          cli::cli_abort("Elements of column {.var itr_vars} must be named lists.")
        }
        
        args %<>% purrr::map(\(arg) {
          
          if (is.character(arg)) {
            result <- rlang::inject(cli::pluralize(arg,
                                                   !!!args$itr_vars,
                                                   .envir = env))
          } else {
            result <- arg
          }
          
          result
        })
      }
      
      fn <- switch(stringr::str_extract(string = args$label,
                                        pattern = "^.{3}"),
                   fig = fig_chunk,
                   tbl = tbl_chunk,
                   cli::cli_abort("Labels must start with either {.val fig-} or {.val tbl-}."))
      
      chunk_opts <- args[names(args) %in% methods::formalArgs(fn)]
      
      rlang::list2(!!chunk_opts$label := rlang::inject(fn(!!!chunk_opts)))
    }) |>
    purrr::list_flatten()
}
# nolint end
```

### `read_chunk_toml`

TODO:

-   Write a JSON schema for the TOML structure and verify with `pal::toml_validate()`. Allow additional keys for max user flexibility.

```{r}
#' Read in Quarto code chunk data
#'
#' Reads in a [TOML](https://toml.io/en/latest) file containing structured figure or table code chunk data, suited to be fed to [chunks()].
#'
#' @param path Path to the TOML file containing structured figure or table code chunk data. A character scalar.
#'
#' @return `r pkgsnip::return_lbl("tibble")`
#' @family chunks
#' @export
read_chunk_toml <- function(path) {
  
  pal::toml_read(input = path) |>
    purrr::imap(\(val, key) {
      
      rlang::inject(tibble::tibble(!!!val)) %>%
        magrittr::set_colnames(value = stringr::str_replace_all(string = colnames(.),
                                                                pattern = "[-.]",
                                                                replacement = "_"))
    }) |>
    purrr::list_rbind()
}
```
